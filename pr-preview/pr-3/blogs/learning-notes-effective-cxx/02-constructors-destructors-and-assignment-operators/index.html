<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>02 | Constructors, Destructorsm and Assignment Operators | ÁßãÊ∞¥¬∑JamesNULLiu</title><meta name=keywords content="c++"><meta name=description content='My learning notes of "Effective C++" by Scott Meyers.'><meta name=author content="jamesnulliu"><link rel=canonical href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/><link crossorigin=anonymous href=/assets/css/stylesheet.62cb9c488bb33c0e9a9d3c29b7f4259cbb0db25aaa19ba672188203d3d5bcaf9.css integrity="sha256-YsucSIuzPA6anTwpt/QlnLsNslqqGbpnIYggPT1byvk=" rel="preload stylesheet" as=style><link rel=icon href=https://jamesnulliu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jamesnulliu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jamesnulliu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jamesnulliu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jamesnulliu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script><meta property="og:url" content="https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/"><meta property="og:site_name" content="ÁßãÊ∞¥¬∑JamesNULLiu"><meta property="og:title" content="02 | Constructors, Destructorsm and Assignment Operators"><meta property="og:description" content='My learning notes of "Effective C++" by Scott Meyers.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2024-06-29T00:02:00+08:00"><meta property="article:modified_time" content="2025-09-12T21:48:31+00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="02 | Constructors, Destructorsm and Assignment Operators"><meta name=twitter:description content='My learning notes of "Effective C++" by Scott Meyers.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://jamesnulliu.github.io/blogs/"},{"@type":"ListItem","position":2,"name":"üìÅ learning notes: effective c++","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/"},{"@type":"ListItem","position":3,"name":"02 | Constructors, Destructorsm and Assignment Operators","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"02 | Constructors, Destructorsm and Assignment Operators","name":"02 | Constructors, Destructorsm and Assignment Operators","description":"My learning notes of \"Effective C++\" by Scott Meyers.","keywords":["c++"],"articleBody":"Term 05 Know what functions C++ silently writes and calls A compiler will automatically generate four functions for a class if the class does not define them by itself:\ndefault constructor copy constructor copy assignment operator destructor The destructor compiler automatically generates is non-virtual, unless that the base class‚Äôs destructor is virtual. (The virtualness mainly comes from the base class.)\nIf a class has reference members or const members, you have to define a copy assignment operator by yourself. The compiler would not generate a default copy assignment operator.\nIf some base class declares that its copy assignment operator is private, the compiler will refuse to generate a default copy assignment operator for its derived class.\nTerm 06 Explicitly disallow the use of compiler-generated functions you do not want One way to disallow the use of copy constructor and copy assignment (more specifically, the compiler-generated ones) is to inherit a class that declared private copy constructor and copy assignment operator.\nTerm 07 Declare destructor virtual in polymorphic base classes When deleting a base pointer pointing to a instance of a derived class, if destructor is declared non-virtual in base class, only the memory of base part would be released.\nConsider about a class Point:\nclass Point { public: Point(int xCoord, int yCoord); ~Point(); private: int x, y; } If ‚Äúint‚Äù takes 32 bits, a Point instance takes 64 bits, and can be easily passed to other languages such as C and FORTRAN.\nHowever, if we declare ~Point() as a virtual function, a vptr (virtual table pointer) would be added to the instance. That causes the instance takes upto 128 bits (2 32-bit integer and 1 64-bit pointer). Moreover, since C and FORTRAN does not have vptr, the class is not portable any more.\nTo create an abstract class, you could (I think you‚Äôd better declare other functions pure virtual) declare a pure virtual destructor; But you has to offer a definition for the destructor outside the class (maybe in a cpp file).\nThe reason is that when an instance of a derived class is dectructed, the destructor of the most derived class is called, and each base class of them is called after. So there is an actor that the pure virtual destructor (of base class) is called inside the derived class.\nSum up Do not delcare a function virtual with no reason. Do not inherit frome a class that does not have a virtual destructor (e.g., std::string, std::set, std::vector, std::map) when the class is not designed for polymorphism. Term 08 Prevent exceptions from leaving destructors Trow exceptions out from a destructor is not encouraged by C++.\nSuppose there are several objects in a block. At the end of the block, all the objects are destroyed automatically.\nIf destructor of the first object throws an exception, every thing is okay; Destructors of the other objects would be called porperly.\nHowever, if the second destructor also throws an exception, the program would either be terminated or cause an undefined behavior (that would be fatal).\nA good strategy is to give the chance to users that they can handle the exceptions themselves.\nIn the following example code, db is an instance of class DBConnect, and meanwhile it is a member of class DBConn.\nBefore calling ~DBConn() automatically, user (instead of the compiler) should call DBConn::close() at first and handle the possible exception thrown by DBConnect::close().\nclass DBConn { public: ... void close() // A close function for users to use { db.close(); closed = true; } ~DBConn() { if(!closed){ try{ db.close(); } catch(...) { Log the faliure; } } } private: DBConnection db; bool closed; } Sum up Do not give any chance for an exception to leave a destructor. Destructor should catch and handle the exceptions inside itself. Offer a function to let user handle the exception that inside the destructor. Term 09: Never call virtual functions during construction or distruction. In C++, when constructing a derived class, the base part is constructed first; And during the construction of base part, the vptr is still pointing at the base class. This means, if you invoke a virtual function in the constructor of a base class, when you create an instance of a derived class, the actual called virtual function is the base version, not the overrided one.\nTerm 10: Have assignment operator return a reference to *this class Widget { public: Widget\u0026 operator+=(const Widget\u0026 rhs) { ...; return *this; } Widget\u0026 operator=(int rhs) { ...; return *this; } private: Bitmap* pb; }; Term 11: Handle assignment to self in operator= Self-assignment could cause a question that the resources are released before they are assigned.\nTraditionally, identity test can check whether there is an assignment to self:\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs) { if(this == \u0026rhs) return *this; // Identity test delete pb; pb = new Bitmap(*rhs.pb); return *this; } However, if the exception occurs (either because the memory is not enough when allocation or the copy constructor throws one exception), the pointer pb would ultimately points to a deleted Bitmap, and that is harmful.\nNowadays more people tends to care for exception safety rather than self-allocation safety. For example:\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs) { Bitmap* pOrigin = pb; pb = new Bitmap(*rhs.pb); delete pOrigin; return *this; } Even if without identity test, self-assignment can be handled, and pb has no chance to point to a deleted Bitmap.\nIdentity test can be put back to the begin of the funtion; But that may lower the efficiency, since self-assignment does not happen so much.\nThere is another way called copy and swap technic. For example:\nWidget\u0026 Widget::operator=(const Widget\u0026 rhs) { Widget temp(rhs); this-\u003eswap(temp); return *this; } Or:\nWidget\u0026 Widget::operator=(Widget rhs) { this-\u003eswap(thd); return *this; } The second way sacrificces clearity; However, because it moves ‚Äúcopy‚Äù action from the function body to ‚Äúparameter-constructing stage‚Äù, sometimes the compiler could generate more efficient codes.\nTerm 12: Copy all parts of an object. Compiler would not warn you if there is a particial copy, and do not let that happen.\nCopy constructor of a derived class should invoke the copy constructor of base class:\nclass Base { public: Base(const Base\u0026 rhs) : name(rhs.name), lastTransaction(rhs.lastTransaction) { log(); } private: std::string name; Date lastTransaction; }; class Derived : Base { public: Derived(const Derived\u0026 rhs) : Base(rhs), // Invoke the copy constructor of base class priority(rhs.priority) { log(); } private: int priority; } Do not have copy assignment operator call copy constructor, vice versa.\nIf you want, you can write a function init() additionally and call it in both functions.\n","wordCount":"1089","inLanguage":"en","datePublished":"2024-06-29T00:02:00+08:00","dateModified":"2025-09-12T21:48:31Z","author":[{"@type":"Person","name":"jamesnulliu"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/"},"publisher":{"@type":"Organization","name":"ÁßãÊ∞¥¬∑JamesNULLiu","logo":{"@type":"ImageObject","url":"https://jamesnulliu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jamesnulliu.github.io/ accesskey=h title="ÁßãÊ∞¥¬∑JamesNULLiu (Alt + H)">ÁßãÊ∞¥¬∑JamesNULLiu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jamesnulliu.github.io/zh/ title=ÁÆÄ‰Ωì‰∏≠Êñá aria-label=ÁÆÄ‰Ωì‰∏≠Êñá>ÁÆÄ‰Ωì‰∏≠Êñá</a></li></ul></div></div><ul id=menu><li><a href=https://jamesnulliu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jamesnulliu.github.io/about_me/ title="About Me"><span>About Me</span></a></li><li><a href=https://jamesnulliu.github.io/blogs/ title=Blogs><span>Blogs</span></a></li><li><a href=https://jamesnulliu.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jamesnulliu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jamesnulliu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jamesnulliu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jamesnulliu.github.io/friends/ title=Friends><span>Friends</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jamesnulliu.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/>Blogs</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/>üìÅ learning notes: effective c++</a></div><h1 class="post-title entry-hint-parent">02 | Constructors, Destructorsm and Assignment Operators</h1><div class=post-description>My learning notes of "Effective C++" by Scott Meyers.</div><div class=post-meta><span title='2024-06-29 00:02:00 +0800 +0800'>Jun-29-2024</span>&nbsp;¬∑&nbsp;6 min&nbsp;¬∑&nbsp;1089 words&nbsp;¬∑&nbsp;jamesnulliu</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#term-05-know-what-functions-c-silently-writes-and-calls aria-label="Term 05 Know what functions C++ silently writes and calls">Term 05 Know what functions C++ silently writes and calls</a></li><li><a href=#term-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want aria-label="Term 06 Explicitly disallow the use of compiler-generated functions you do not want">Term 06 Explicitly disallow the use of compiler-generated functions you do not want</a></li><li><a href=#term-07-declare-destructor-virtual-in-polymorphic-base-classes aria-label="Term 07 Declare destructor virtual in polymorphic base classes">Term 07 Declare destructor virtual in polymorphic base classes</a><ul><li><a href=#sum-up aria-label="Sum up">Sum up</a></li></ul></li><li><a href=#term-08-prevent-exceptions-from-leaving-destructors aria-label="Term 08 Prevent exceptions from leaving destructors">Term 08 Prevent exceptions from leaving destructors</a><ul><li><a href=#sum-up-1 aria-label="Sum up">Sum up</a></li></ul></li><li><a href=#term-09-never-call-virtual-functions-during-construction-or-distruction aria-label="Term 09: Never call virtual functions during construction or distruction.">Term 09: Never call virtual functions during construction or distruction.</a></li><li><a href=#term-10-have-assignment-operator-return-a-reference-to-this aria-label="Term 10: Have assignment operator return a reference to *this">Term 10: Have assignment operator return a reference to <code>*this</code></a></li><li><a href=#term-11-handle-assignment-to-self-in-operator aria-label="Term 11: Handle assignment to self in operator=">Term 11: Handle assignment to self in <code>operator=</code></a></li><li><a href=#term-12-copy-all-parts-of-an-object aria-label="Term 12: Copy all parts of an object.">Term 12: Copy all parts of an object.</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{let e=null;const t=window.innerHeight+window.pageYOffset>=document.body.offsetHeight-100;if(t)e=elements[elements.length-1];else{let t=null,n=1/0;elements.forEach(e=>{const s=getOffsetTop(e)-window.pageYOffset;if(s<=window.innerHeight*.3){const o=Math.abs(s);o<n&&(n=o,t=e)}}),e=t||elements[0]}if(e&&e!==activeElement){if(activeElement){const t=encodeURI(activeElement.getAttribute("id")).toLowerCase(),e=document.querySelector(`.inner ul li a[href="#${t}"]`);e&&e.classList.remove("active")}activeElement=e;const n=encodeURI(activeElement.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);t&&(t.classList.add("active"),document.getElementById("toc-container").classList.contains("wide")&&scrollTocToActiveItem(t))}},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}function scrollTocToActiveItem(e){const t=document.querySelector(".toc .inner");if(!t||!e)return;const n=t.getBoundingClientRect(),s=e.getBoundingClientRect(),o=n.height/2,i=s.top-n.top+t.scrollTop,a=i-o;t.scrollTo({top:Math.max(0,a),behavior:"smooth"})}</script><div class=post-content><h2 id=term-05-know-what-functions-c-silently-writes-and-calls>Term 05 Know what functions C++ silently writes and calls<a hidden class=anchor aria-hidden=true href=#term-05-know-what-functions-c-silently-writes-and-calls>#</a></h2><p>A compiler will automatically generate four functions for a class if the class does not define them by itself:</p><ul><li>default constructor</li><li>copy constructor</li><li>copy assignment operator</li><li>destructor</li></ul><p>The destructor compiler automatically generates is non-virtual, unless that the base class&rsquo;s destructor is virtual. (The virtualness mainly comes from the base class.)</p><p>If a class has reference members or const members, you have to define a copy assignment operator by yourself. The compiler would not generate a default copy assignment operator.</p><p>If some base class declares that its copy assignment operator is private, the compiler will refuse to generate a default copy assignment operator for its derived class.</p><h2 id=term-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want>Term 06 Explicitly disallow the use of compiler-generated functions you do not want<a hidden class=anchor aria-hidden=true href=#term-06-explicitly-disallow-the-use-of-compiler-generated-functions-you-do-not-want>#</a></h2><p>One way to disallow the use of copy constructor and copy assignment (more specifically, the compiler-generated ones) is to inherit a class that declared private copy constructor and copy assignment operator.</p><h2 id=term-07-declare-destructor-virtual-in-polymorphic-base-classes>Term 07 Declare destructor virtual in polymorphic base classes<a hidden class=anchor aria-hidden=true href=#term-07-declare-destructor-virtual-in-polymorphic-base-classes>#</a></h2><p>When deleting a base pointer pointing to a instance of a derived class, if destructor is declared non-virtual in base class, only the memory of base part would be released.</p><p>Consider about a class <code>Point</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Point</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Point</span><span class=p>(</span><span class=kt>int</span> <span class=n>xCoord</span><span class=p>,</span> <span class=kt>int</span> <span class=n>yCoord</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Point</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If &ldquo;int&rdquo; takes 32 bits, a <code>Point</code> instance takes 64 bits, and can be easily passed to other languages such as C and FORTRAN.</p><p>However, if we declare <code>~Point()</code> as a virtual function, a <strong>vptr</strong> (virtual table pointer) would be added to the instance. That causes the instance takes upto 128 bits (2 32-bit integer and 1 64-bit pointer). Moreover, since C and FORTRAN does not have vptr, the class is not portable any more.</p><p>To create an abstract class, you could (I think you&rsquo;d better declare other functions pure virtual) declare a pure virtual destructor; But you has to offer a definition for the destructor outside the class (maybe in a cpp file).<br>The reason is that when an instance of a derived class is dectructed, the destructor of the most derived class is called, and each base class of them is called after. So there is an actor that the pure virtual destructor (of base class) is called inside the derived class.</p><h3 id=sum-up>Sum up<a hidden class=anchor aria-hidden=true href=#sum-up>#</a></h3><ul><li>Do not delcare a function virtual with no reason.</li><li>Do not inherit frome a class that does not have a virtual destructor (e.g., std::string, std::set, std::vector, std::map) when the class is not designed for polymorphism.</li></ul><h2 id=term-08-prevent-exceptions-from-leaving-destructors>Term 08 Prevent exceptions from leaving destructors<a hidden class=anchor aria-hidden=true href=#term-08-prevent-exceptions-from-leaving-destructors>#</a></h2><p>Trow exceptions out from a destructor is not encouraged by C++.</p><p>Suppose there are several objects in a block. At the end of the block, all the objects are destroyed automatically.<br>If destructor of the first object throws an exception, every thing is okay; Destructors of the other objects would be called porperly.<br>However, if the second destructor also throws an exception, the program would either be terminated or cause an undefined behavior (that would be fatal).</p><p>A good strategy is to give the chance to users that they can handle the exceptions themselves.</p><p>In the following example code, db is an instance of class <code>DBConnect</code>, and meanwhile it is a member of class <code>DBConn</code>.<br>Before calling <code>~DBConn()</code> automatically, user (instead of the compiler) should call <code>DBConn::close()</code> at first and handle the possible exception thrown by <code>DBConnect::close()</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>DBConn</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=n>close</span><span class=p>()</span> <span class=c1>// A close function for users to use
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>db</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>		<span class=n>closed</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>DBConn</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>closed</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=k>try</span><span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>db</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span> <span class=k>catch</span><span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>Log</span> <span class=n>the</span> <span class=n>faliure</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>DBConnection</span> <span class=n>db</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>bool</span> <span class=n>closed</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=sum-up-1>Sum up<a hidden class=anchor aria-hidden=true href=#sum-up-1>#</a></h3><ul><li>Do not give any chance for an exception to leave a destructor. Destructor should catch and handle the exceptions inside itself.</li><li>Offer a function to let user handle the exception that inside the destructor.</li></ul><h2 id=term-09-never-call-virtual-functions-during-construction-or-distruction>Term 09: Never call virtual functions during construction or distruction.<a hidden class=anchor aria-hidden=true href=#term-09-never-call-virtual-functions-during-construction-or-distruction>#</a></h2><p>In C++, when constructing a derived class, the base part is constructed first; And during the construction of base part, the vptr is still pointing at the base class. This means, if you invoke a virtual function in the constructor of a base class, when you create an instance of a derived class, the actual called virtual function is the base version, not the overrided one.</p><h2 id=term-10-have-assignment-operator-return-a-reference-to-this>Term 10: Have assignment operator return a reference to <code>*this</code><a hidden class=anchor aria-hidden=true href=#term-10-have-assignment-operator-return-a-reference-to-this>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Widget</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>+=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=p>...;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=kt>int</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=p>...;</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Bitmap</span><span class=o>*</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h2 id=term-11-handle-assignment-to-self-in-operator>Term 11: Handle assignment to self in <code>operator=</code><a hidden class=anchor aria-hidden=true href=#term-11-handle-assignment-to-self-in-operator>#</a></h2><p>Self-assignment could cause a question that the resources are released before they are assigned.</p><p>Traditionally, <strong>identity test</strong> can check whether there is an assignment to self:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>  <span class=c1>// Identity test
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>delete</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bitmap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, if the exception occurs (either because the memory is not enough when allocation or the copy constructor throws one exception), the pointer <code>pb</code> would ultimately points to a deleted Bitmap, and that is harmful.</p><p>Nowadays more people tends to care for <strong>exception safety</strong> rather than <strong>self-allocation safety</strong>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Bitmap</span><span class=o>*</span> <span class=n>pOrigin</span> <span class=o>=</span> <span class=n>pb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>pb</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Bitmap</span><span class=p>(</span><span class=o>*</span><span class=n>rhs</span><span class=p>.</span><span class=n>pb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>delete</span> <span class=n>pOrigin</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Even if without identity test, self-assignment can be handled, and <code>pb</code> has no chance to point to a deleted Bitmap.</p><p>Identity test can be put back to the begin of the funtion; But that may lower the efficiency, since self-assignment does not happen so much.</p><p>There is another way called <strong>copy and swap</strong> technic. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Widget</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>Widget</span> <span class=nf>temp</span><span class=p>(</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>swap</span><span class=p>(</span><span class=n>temp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Or:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Widget</span><span class=o>&amp;</span> <span class=n>Widget</span><span class=o>::</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Widget</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>this</span><span class=o>-&gt;</span><span class=n>swap</span><span class=p>(</span><span class=n>thd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The second way sacrificces clearity; However, because it moves &ldquo;copy&rdquo; action from the function body to &ldquo;parameter-constructing stage&rdquo;, sometimes the compiler could generate more efficient codes.</p><h2 id=term-12-copy-all-parts-of-an-object>Term 12: Copy all parts of an object.<a hidden class=anchor aria-hidden=true href=#term-12-copy-all-parts-of-an-object>#</a></h2><p>Compiler would not warn you if there is a particial copy, and do not let that happen.</p><p>Copy constructor of a derived class should invoke the copy constructor of base class:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Base</span><span class=p>(</span><span class=k>const</span> <span class=n>Base</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>name</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>name</span><span class=p>),</span>
</span></span><span class=line><span class=cl>			<span class=n>lastTransaction</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>lastTransaction</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>Date</span> <span class=n>lastTransaction</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Derived</span> <span class=o>:</span> <span class=n>Base</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Derived</span><span class=p>(</span><span class=k>const</span> <span class=n>Derived</span><span class=o>&amp;</span> <span class=n>rhs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=o>:</span> <span class=n>Base</span><span class=p>(</span><span class=n>rhs</span><span class=p>),</span>  <span class=c1>// Invoke the copy constructor of base class
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>priority</span><span class=p>(</span><span class=n>rhs</span><span class=p>.</span><span class=n>priority</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>log</span><span class=p>();</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>priority</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Do not have copy assignment operator call copy constructor, vice versa.<br>If you want, you can write a function <code>init()</code> additionally and call it in both functions.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jamesnulliu.github.io/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/><span class=title>¬´ Prev</span><br><span>03 | Resource Management</span>
</a><a class=next href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/><span class=title>Next ¬ª</span><br><span>01 | Accustoming Yourself to C++</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=jamesnulliu/jamesnulliu.github.io data-repo-id=R_kgDOMPCQIw data-category=Announcements data-category-id=DIC_kwDOMPCQI84Cgb2t data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>¬© 2024-2025 JamesNULLiu</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>