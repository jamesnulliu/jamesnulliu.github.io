<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>01 | Accustoming Yourself to C++ | ÁßãÊ∞¥¬∑JamesNULLiu</title><meta name=keywords content="c++"><meta name=description content='My learning notes of "Effective C++" by Scott Meyers.'><meta name=author content="jamesnulliu"><link rel=canonical href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/><link crossorigin=anonymous href=/assets/css/stylesheet.62cb9c488bb33c0e9a9d3c29b7f4259cbb0db25aaa19ba672188203d3d5bcaf9.css integrity="sha256-YsucSIuzPA6anTwpt/QlnLsNslqqGbpnIYggPT1byvk=" rel="preload stylesheet" as=style><link rel=icon href=https://jamesnulliu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jamesnulliu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jamesnulliu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jamesnulliu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jamesnulliu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script><meta property="og:url" content="https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/"><meta property="og:site_name" content="ÁßãÊ∞¥¬∑JamesNULLiu"><meta property="og:title" content="01 | Accustoming Yourself to C++"><meta property="og:description" content='My learning notes of "Effective C++" by Scott Meyers.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2024-06-29T00:01:00+08:00"><meta property="article:modified_time" content="2025-09-12T16:00:18-07:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="01 | Accustoming Yourself to C++"><meta name=twitter:description content='My learning notes of "Effective C++" by Scott Meyers.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://jamesnulliu.github.io/blogs/"},{"@type":"ListItem","position":2,"name":"üìÅ learning notes: effective c++","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/"},{"@type":"ListItem","position":3,"name":"01 | Accustoming Yourself to C++","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"01 | Accustoming Yourself to C++","name":"01 | Accustoming Yourself to C\u002b\u002b","description":"My learning notes of \"Effective C++\" by Scott Meyers.","keywords":["c++"],"articleBody":"Term 01: View C++ as a federation of languages. Today‚Äôs C++ is a multiparadigm programming language, one supporting a combination of procedural, object-oriented, functional, generic, and metaprogramming features.\nTerm 02: Prefer consts, enums, inlines to #defines The substitution of a macro could result in multiple copies of the object in your object code, while the use of the constant should never result in more than one copy.\nüéº Constant Pointer To define a constant char*-based string in a header file, for example, you have to write const twice:\n// File header.h const char* const authorName = \"Scott Meyers\"; üí° Note: A constant object can be defined in a header file, and there will be no redefinition error when the header file is included in multiple source files.\nüéº Static Constant Members of a Class To limit the scope of a constant to a class, you must make it a member, and to ensure there‚Äôs at most one copy of the constant, you must make it a static member:\n// File GamePlayer.h class GamePlayer { private: static const int NumTurns = 5; // Declaration of a const int scores[NumTurns]; } What you see above is a declaration for NumTurns, not a definition.\nUsually, C++ requires that you provide a definition for anything you use, but classspecific constants that are static and of integral type (e.g., integers, chars, bools) are an exception.\nAs long as you don‚Äôt take their address, you can declare them and use them without providing a definition. If you do take the address of a class constant, or if your compiler incorrectly insists on a definition even if you don‚Äôt take the address, you should provide a separate definition like this:\n// File GamePlayer.cpp const int GamePlayer::NumTurns; // Definition of a const You put this in an implementation file, not a header file. Because the initial value of class constants is provided where the constant is declared (e.g., NumTurns is initialized to 5 when it is declared), no initial value is permitted at the point of definition.\nFor non-integral types, you must provide a definition for the constant in the header file, like this:\n// File CostEstimate.h class A { private: static const double FudgeFactor; // Declaration of a class static const } // File CostEstimate.cpp const double CostEstimate::FudgeFactor = 1.35; // Defination of a class static const üí° Keypoints:\nDeclare class-specific constants as static members of the class. Provide a separate definition in an implementation file if the compiler requires it. Only for static constants of integral type, provide an initial value at the point of declaration. Otherwise, provide an initial value of a static member at the point of definition. üéº Enum Hack class GamePlayer2 { private: enum { NumTurns = 5}; // \"the enum hack\" - let {NumTurns} be a marker of 5 int scores[NumTurns]; // valid } The enum hack is worth knowing about for several reasons.\nThe enum hack behaves in some ways more like a #define than a const does, and sometimes that‚Äôs what you want. It‚Äôs not legal to take the address of an enum, and it‚Äôs typically not legal to take the address of a #define, either. Also, like #defines, enums never result in unnecessary memory allocation. The enum hack is purely pragmatic. The enum hack is a fundamental technique of template metaprogramming (item 48). üéº Inline Use inline functions instead of #defines.\n#define CALL_WITH_MAX(a, b) f((a)\u003e(b)?(a):(b)) int a = 5, b = 0; CALL_WITH_MAX(++a, b); // a is incremented twice CALL_WITH_MAX(++a, b+10); // a is incremented once template\u003cclass T\u003e inline void callWithMax(const T\u0026 a, const T\u0026 b) { f(a \u003e b ? a : b); } Term 03: Use const Whenever Possible üéº const and Pointers If the word const appears to the left of the asterisk, what‚Äôs pointed to is constant; if the word const appears to the right of the asterisk, the pointer itself is constant; if const appears on both sides, both are constant.\nFor example:\nchar greeting[] = \"Hello\"; char* p = greeting; // non-const pointer, non-const data const char* p = greeting; // non-const pointer, const data char* const p = greeting; // const pointer, non-const data const char* const p = greeting; // const pointer, const data üéº Use const to Restrict the User‚Äôs Behavior class A { public: A operator+(const A\u0026 a) { return A(); } }; int main() { A a1, a2; a1 + a2 = A(); // This is not expected. return 0; } Where a1 + a2 = A(); is not expected, because the result of a1 + a2 is a temporary object, and it is not allowed to assign a value to a temporary object.\nTo prevent this, you can add const to the return value of the operator+ function:\nclass A { public: const A operator+(const A\u0026 a) { return A(); } }; üéº Const Member Functions There are two prevailing notions: bitwise constness (also known as physical constness) and logical constness.\nThe bitwise const camp believes that a member function is const if and only if it doesn‚Äôt modify any of the object‚Äôs data members (excluding those that are static), i.e., if it doesn‚Äôt modify any of the bits inside the object.\nThe nice thing about bitwise constness is that it‚Äôs easy to detect violations: compilers just look for assignments to data members.\nUnfortunately, many member functions that don‚Äôt act very const pass the bitwise test. For exapmle:\nclass CTextBlock { public: ... char\u0026 operator[](std::size_t position) const { return pText[position]; // Not suitable } private: char* pText; } It is worth noting that you should return a const char\u0026 instead of a char\u0026 in the operator[] function above.\nThis leads to the notion of logical constness. Adherents to this philosophy (and you should be among them) ‚Äî argue that a const member function might modify some of the bits in the object on which it‚Äôs invoked, but only in ways that clients cannot detect. For example:\nclass CTextBlock { public: std::size_t length() const { if(!lengthIsValid) { textLength = std::strlen(pText); lengthIsValid = true; } return textLength; } private: char* pText; mutable std::size_t textLength; mutable bool lengthIsValid; } üéº Avoiding Duplication in const and Non-const Member Functions When you have a const and a non-const member function that have essentially identical implementations, you can avoid code duplication by having the non-const member function call the const member function. For example:\nclass TextBlock { public: const char\u0026 operator[](std::size_t position) const { return text[position]; } char\u0026 operator[](std::size_t position) { return const_cast\u003cchar\u0026\u003e( static_cast\u003cconst TextBlock\u0026\u003e(*this)[position] ); } } üí° Note: Do not avoiding duplication by having the const version call the non-const version. A const member function promises never to change the logical state of its object, but a non-const member function makes no such promise.\nüéº Things to Remember Declaring something const helps compilers detect usage errors. const can be applied to objects at any scope, to function parameters and return types, and to member functions as a whole. Compilers enforce bitwise constness, but you should program using logical constness. When const and non-const member functions have essentially identical implementations, code duplication can be avoided by having the non-const version call the const version. Term 04: Make Sure the Objects are initialized before they are used Always initialize objects before they are used.\nüéº Member initialization list Always use the member initialization list to initialize member objects.\nOne aspect of C++ that isn‚Äôt fickle is the order in which an object‚Äôs data is initialized. This order is always the same: base classes are initialized before derived classes (see also Item 12), and within a class, data members are initialized in the order in which they are declared.\nüéº Initialize Static Objects A static object is one that exists from the time it‚Äôs constructed until the end of the program. Stack and heap-based objects are thus excluded.\nIncluded are:\nglobal objects objects defined at namespace scope objects declared static inside classes objects declared static inside functions objects declared static at file scope Static objects inside functions are known as local static objects (because they‚Äôre local to a function), and the other kinds of static objects are known as non-local static objects.\nStatic objects are destroyed when the program exits, i.e., their destructors are called when main finishes executing.\n‚ö† Warning: If initialization of a non-local static object in one translation unit uses a non-local static object in a different translation unit, the object it uses could be uninitialized, because the relative order of initialization of non-local static objects defined in different translation units is undefined.\nüí¨ Multiple translation units and non-local static objects is generated through implicit template instantiations (which may themselves arise via implicit template instantiations). It‚Äôs not only impossible to determine the right order of initialization, it‚Äôs typically not even worth looking for special cases where it is possible to determine the right order.\nTo avoid the problem of undefined initialization order, you can use a function-local static object instead of a non-local static object. These functions return references to the objects they contain. (Aficionados of design patterns will recognize this as a common implementation of the Singleton Pattern.)\nFor example:\nclass FileSystem {...}; inline FileSystem\u0026 tfs() { static FileSystem fs; return fs; } class Directory {...}; Directory::Directory() { ... std::size_t disks = tfs().numDisks(); ... } inline Directory\u0026 tempDir() { static Directory td; return td; } This approach is founded on C++‚Äôs guarantee that local static objects are initialized when the object‚Äôs definition is first encountered during a call to that function. So if you replace direct accesses to non-local static objects with calls to functions that return references to local static objects, you‚Äôre guaranteed that the references you get back will refer to initialized objects. As a bonus, if you never call a function emulating a non-local static object, you never incur the cost of constructing and destructing the object, something that can‚Äôt be said for true non-local static objects.\nHowever, the fact that these functions contain static objects makes them problematic in multithreaded systems. Then again, any kind of non-const static object ‚Äî local or non-local ‚Äî is trouble waiting to happen in the presence of multiple threads.\nOne way to deal with such trouble is to manually invoke all the reference-returning functions during the single-threaded startup portion of the program. This eliminates initialization-related race conditions.\nüéº Things to Remember Manually initialize objects of built-in type, because C++ only sometimes initializes them itself. In a constructor, prefer use of the member initialization list to assignment inside the body of the constructor. List data members in the initialization list in the same order they‚Äôre declared in the class. Avoid initialization order problems across translation units by replacing non-local static objects with local static objects. ","wordCount":"1785","inLanguage":"en","datePublished":"2024-06-29T00:01:00+08:00","dateModified":"2025-09-12T16:00:18-07:00","author":[{"@type":"Person","name":"jamesnulliu"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/01-accustoming-yourself-to-cxx/"},"publisher":{"@type":"Organization","name":"ÁßãÊ∞¥¬∑JamesNULLiu","logo":{"@type":"ImageObject","url":"https://jamesnulliu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jamesnulliu.github.io/ accesskey=h title="ÁßãÊ∞¥¬∑JamesNULLiu (Alt + H)">ÁßãÊ∞¥¬∑JamesNULLiu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jamesnulliu.github.io/zh/ title=ÁÆÄ‰Ωì‰∏≠Êñá aria-label=ÁÆÄ‰Ωì‰∏≠Êñá>ÁÆÄ‰Ωì‰∏≠Êñá</a></li></ul></div></div><ul id=menu><li><a href=https://jamesnulliu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jamesnulliu.github.io/about_me/ title="About Me"><span>About Me</span></a></li><li><a href=https://jamesnulliu.github.io/blogs/ title=Blogs><span>Blogs</span></a></li><li><a href=https://jamesnulliu.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jamesnulliu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jamesnulliu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jamesnulliu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jamesnulliu.github.io/friends/ title=Friends><span>Friends</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jamesnulliu.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/>Blogs</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/>üìÅ learning notes: effective c++</a></div><h1 class="post-title entry-hint-parent">01 | Accustoming Yourself to C++</h1><div class=post-description>My learning notes of "Effective C++" by Scott Meyers.</div><div class=post-meta><span title='2024-06-29 00:01:00 +0800 +0800'>Jun-29-2024</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;1785 words&nbsp;¬∑&nbsp;jamesnulliu</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#term-01-view-c-as-a-federation-of-languages aria-label="Term 01: View C++ as a federation of languages.">Term 01: View C++ as a federation of languages.</a></li><li><a href=#term-02-prefer-consts-enums-inlines-to-defines aria-label="Term 02: Prefer consts, enums, inlines to #defines">Term 02: Prefer consts, enums, inlines to #defines</a><ul><li><a href=#-constant-pointer aria-label="üéº Constant Pointer">üéº Constant Pointer</a></li><li><a href=#-static-constant-members-of-a-class aria-label="üéº Static Constant Members of a Class">üéº Static Constant Members of a Class</a></li><li><a href=#-enum-hack aria-label="üéº Enum Hack">üéº Enum Hack</a></li><li><a href=#-inline aria-label="üéº Inline">üéº Inline</a></li></ul></li><li><a href=#term-03-use-const-whenever-possible aria-label="Term 03: Use const Whenever Possible">Term 03: Use <code>const</code> Whenever Possible</a><ul><li><a href=#-const-and-pointers aria-label="üéº const and Pointers">üéº <code>const</code> and Pointers</a></li><li><a href=#-use-const-to-restrict-the-users-behavior aria-label="üéº Use const to Restrict the User&rsquo;s Behavior">üéº Use <code>const</code> to Restrict the User&rsquo;s Behavior</a></li><li><a href=#-const-member-functions aria-label="üéº Const Member Functions">üéº Const Member Functions</a></li><li><a href=#-avoiding-duplication-in-const-and-non-const-member-functions aria-label="üéº Avoiding Duplication in const and Non-const Member Functions">üéº Avoiding Duplication in const and Non-const Member Functions</a></li><li><a href=#-things-to-remember aria-label="üéº Things to Remember">üéº Things to Remember</a></li></ul></li><li><a href=#term-04-make-sure-the-objects-are-initialized-before-they-are-used aria-label="Term 04: Make Sure the Objects are initialized before they are used">Term 04: Make Sure the Objects are initialized before they are used</a><ul><li><a href=#-member-initialization-list aria-label="üéº Member initialization list">üéº Member initialization list</a></li><li><a href=#-initialize-static-objects aria-label="üéº Initialize Static Objects">üéº Initialize Static Objects</a></li><li><a href=#-things-to-remember-1 aria-label="üéº Things to Remember">üéº Things to Remember</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{let e=null;const t=window.innerHeight+window.pageYOffset>=document.body.offsetHeight-100;if(t)e=elements[elements.length-1];else{let t=null,n=1/0;elements.forEach(e=>{const s=getOffsetTop(e)-window.pageYOffset;if(s<=window.innerHeight*.3){const o=Math.abs(s);o<n&&(n=o,t=e)}}),e=t||elements[0]}if(e&&e!==activeElement){if(activeElement){const t=encodeURI(activeElement.getAttribute("id")).toLowerCase(),e=document.querySelector(`.inner ul li a[href="#${t}"]`);e&&e.classList.remove("active")}activeElement=e;const n=encodeURI(activeElement.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);t&&(t.classList.add("active"),document.getElementById("toc-container").classList.contains("wide")&&scrollTocToActiveItem(t))}},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}function scrollTocToActiveItem(e){const t=document.querySelector(".toc .inner");if(!t||!e)return;const n=t.getBoundingClientRect(),s=e.getBoundingClientRect(),o=n.height/2,i=s.top-n.top+t.scrollTop,a=i-o;t.scrollTo({top:Math.max(0,a),behavior:"smooth"})}</script><div class=post-content><h2 id=term-01-view-c-as-a-federation-of-languages>Term 01: View C++ as a federation of languages.<a hidden class=anchor aria-hidden=true href=#term-01-view-c-as-a-federation-of-languages>#</a></h2><p>Today&rsquo;s C++ is a multiparadigm programming language, one supporting a combination of procedural, object-oriented, functional, generic, and metaprogramming features.</p><h2 id=term-02-prefer-consts-enums-inlines-to-defines>Term 02: Prefer consts, enums, inlines to #defines<a hidden class=anchor aria-hidden=true href=#term-02-prefer-consts-enums-inlines-to-defines>#</a></h2><p>The substitution of a macro could result in multiple copies of the object in your object code, while the use of the constant should never result in more than one copy.</p><h3 id=-constant-pointer>üéº Constant Pointer<a hidden class=anchor aria-hidden=true href=#-constant-pointer>#</a></h3><p>To define a constant char*-based string in a header file, for example, you have to write const twice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// File header.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>authorName</span> <span class=o>=</span> <span class=s>&#34;Scott Meyers&#34;</span><span class=p>;</span>
</span></span></code></pre></div><blockquote><p>üí° <strong>Note</strong>: A constant object can be defined in a header file, and there will be no redefinition error when the header file is included in multiple source files.</p></blockquote><h3 id=-static-constant-members-of-a-class>üéº Static Constant Members of a Class<a hidden class=anchor aria-hidden=true href=#-static-constant-members-of-a-class>#</a></h3><p>To limit the scope of a constant to a class, you must make it a member, and to ensure there&rsquo;s at most one copy of the constant, you must make it a static member:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// File GamePlayer.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GamePlayer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>NumTurns</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>  <span class=c1>// Declaration of a const
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>scores</span><span class=p>[</span><span class=n>NumTurns</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>What you see above is a declaration for <code>NumTurns</code>, not a definition.</p><p>Usually, C++ requires that you provide a definition for anything you use, but classspecific constants that are <strong>static and of integral type</strong> (e.g., integers, chars, bools) are an exception.</p><p>As long as you don&rsquo;t take their address, you can declare them and use them without providing a definition. If you do take the address of a class constant, or if your compiler incorrectly insists on a definition even if you don&rsquo;t take the address, you should provide a separate definition like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// File GamePlayer.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=n>GamePlayer</span><span class=o>::</span><span class=n>NumTurns</span><span class=p>;</span>  <span class=c1>// Definition of a const
</span></span></span></code></pre></div><p>You put this in an implementation file, not a header file. Because the initial value of class constants is provided where the constant is declared (e.g., <code>NumTurns</code> is initialized to 5 when it is declared), no initial value is permitted at the point of definition.</p><p>For non-integral types, you must provide a definition for the constant in the header file, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// File CostEstimate.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>double</span> <span class=n>FudgeFactor</span><span class=p>;</span>  <span class=c1>// Declaration of a class static const
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// File CostEstimate.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>double</span> <span class=n>CostEstimate</span><span class=o>::</span><span class=n>FudgeFactor</span> <span class=o>=</span> <span class=mf>1.35</span><span class=p>;</span>  <span class=c1>// Defination of a class static const
</span></span></span></code></pre></div><blockquote><p>üí° <strong>Keypoints</strong>:</p><ol><li>Declare class-specific constants as <code>static</code> members of the class.</li><li>Provide a separate definition in an implementation file if the compiler requires it.</li><li>Only for <strong>static</strong> <strong>constants</strong> of <strong>integral</strong> type, provide an initial value at the point of declaration. Otherwise, provide an initial value of a static member at the point of definition.</li></ol></blockquote><h3 id=-enum-hack>üéº Enum Hack<a hidden class=anchor aria-hidden=true href=#-enum-hack>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>GamePlayer2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>enum</span> <span class=p>{</span> <span class=n>NumTurns</span> <span class=o>=</span> <span class=mi>5</span><span class=p>};</span>  <span class=c1>// &#34;the enum hack&#34; - let {NumTurns} be a marker of 5
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>scores</span><span class=p>[</span><span class=n>NumTurns</span><span class=p>];</span>  <span class=c1>// valid
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The enum hack is worth knowing about for several reasons.</p><ol><li>The enum hack behaves in some ways more like a #define than a const does, and sometimes that&rsquo;s what you want. It&rsquo;s not legal to take the address of an enum, and it&rsquo;s typically not legal to take the address of a #define, either. Also, like #defines, enums never result in unnecessary memory allocation.</li><li>The enum hack is purely pragmatic. The enum hack is a fundamental technique of template metaprogramming (item 48).</li></ol><h3 id=-inline>üéº Inline<a hidden class=anchor aria-hidden=true href=#-inline>#</a></h3><p>Use inline functions instead of #defines.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define CALL_WITH_MAX(a, b) f((a)&gt;(b)?(a):(b))
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>5</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>CALL_WITH_MAX</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>);</span>     <span class=c1>// a is incremented twice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>CALL_WITH_MAX</span><span class=p>(</span><span class=o>++</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=o>+</span><span class=mi>10</span><span class=p>);</span>  <span class=c1>// a is incremented once
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>template</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>callWithMax</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>(</span><span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span> <span class=o>?</span> <span class=nl>a</span> <span class=p>:</span> <span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=term-03-use-const-whenever-possible>Term 03: Use <code>const</code> Whenever Possible<a hidden class=anchor aria-hidden=true href=#term-03-use-const-whenever-possible>#</a></h2><h3 id=-const-and-pointers>üéº <code>const</code> and Pointers<a hidden class=anchor aria-hidden=true href=#-const-and-pointers>#</a></h3><p>If the word const appears to the left of the asterisk, what&rsquo;s pointed to is constant; if the word const appears to the right of the asterisk, the pointer itself is constant; if const appears on both sides, both are constant.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>char</span> <span class=n>greeting</span><span class=p>[]</span> <span class=o>=</span> <span class=s>&#34;Hello&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>greeting</span><span class=p>;</span>  <span class=c1>// non-const pointer, non-const data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>greeting</span><span class=p>;</span>  <span class=c1>// non-const pointer, const data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>p</span> <span class=o>=</span> <span class=n>greeting</span><span class=p>;</span>  <span class=c1>// const pointer, non-const data
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=k>const</span> <span class=n>p</span> <span class=o>=</span> <span class=n>greeting</span><span class=p>;</span>  <span class=c1>// const pointer, const data
</span></span></span></code></pre></div><h3 id=-use-const-to-restrict-the-users-behavior>üéº Use <code>const</code> to Restrict the User&rsquo;s Behavior<a hidden class=anchor aria-hidden=true href=#-use-const-to-restrict-the-users-behavior>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>A</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>a1</span><span class=p>,</span> <span class=n>a2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a1</span> <span class=o>+</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>A</span><span class=p>();</span>  <span class=c1>// This is not expected.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Where <code>a1 + a2 = A();</code> is not expected, because the result of <code>a1 + a2</code> is a temporary object, and it is not allowed to assign a value to a temporary object.</p><p>To prevent this, you can add <code>const</code> to the return value of the <code>operator+</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>A</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>A</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=-const-member-functions>üéº Const Member Functions<a hidden class=anchor aria-hidden=true href=#-const-member-functions>#</a></h3><p>There are two prevailing notions: <strong><em>bitwise</em> constness</strong> (also known as physical constness) and <strong><em>logical</em> constness</strong>.</p><p>The bitwise const camp believes that a member function is const if and only if it doesn&rsquo;t modify any of the object&rsquo;s data members (excluding those that are static), i.e., if it doesn&rsquo;t modify any of the bits inside the object.</p><p>The nice thing about bitwise constness is that it&rsquo;s easy to detect violations: compilers just look for assignments to data members.</p><p>Unfortunately, many member functions that don&rsquo;t act very const pass the bitwise test. For exapmle:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CTextBlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>position</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>pText</span><span class=p>[</span><span class=n>position</span><span class=p>];</span>  <span class=c1>// Not suitable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>pText</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>It is worth noting that you should return a <code>const char&</code> instead of a <code>char&</code> in the <code>operator[]</code> function above.</p></blockquote><p>This leads to the notion of <strong>logical constness</strong>. Adherents to this philosophy (and you should be among them) ‚Äî argue that a const member function might modify some of the bits in the object on which it&rsquo;s invoked, but only in ways that clients cannot detect. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CTextBlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>length</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=n>lengthIsValid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>textLength</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>strlen</span><span class=p>(</span><span class=n>pText</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>lengthIsValid</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>textLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>*</span> <span class=n>pText</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>textLength</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=kt>bool</span> <span class=n>lengthIsValid</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-avoiding-duplication-in-const-and-non-const-member-functions>üéº Avoiding Duplication in const and Non-const Member Functions<a hidden class=anchor aria-hidden=true href=#-avoiding-duplication-in-const-and-non-const-member-functions>#</a></h3><p>When you have a const and a non-const member function that have essentially identical implementations, you can <strong>avoid code duplication by having the non-const member function call the const member function</strong>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>TextBlock</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>position</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>text</span><span class=p>[</span><span class=n>position</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[](</span><span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>position</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> 
</span></span><span class=line><span class=cl>            <span class=k>const_cast</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&amp;&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=k>static_cast</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>TextBlock</span><span class=o>&amp;&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>)[</span><span class=n>position</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><blockquote><p>üí° <strong>Note</strong>: Do not avoiding duplication by having the const version call the non-const version. A const member function promises never to change the logical state of its object, but a non-const member function makes no such promise.</p></blockquote><h3 id=-things-to-remember>üéº Things to Remember<a hidden class=anchor aria-hidden=true href=#-things-to-remember>#</a></h3><ul><li>Declaring something <code>const</code> helps compilers detect usage errors. <code>const</code> can be applied to objects at any scope, to function parameters and return types, and to member functions as a whole.</li><li>Compilers enforce bitwise constness, but you should program using logical constness.</li><li>When <code>const</code> and <code>non-const</code> member functions have essentially identical implementations, code duplication can be avoided by having the non-const version call the const version.</li></ul><h2 id=term-04-make-sure-the-objects-are-initialized-before-they-are-used>Term 04: Make Sure the Objects are initialized before they are used<a hidden class=anchor aria-hidden=true href=#term-04-make-sure-the-objects-are-initialized-before-they-are-used>#</a></h2><p>Always initialize objects before they are used.</p><h3 id=-member-initialization-list>üéº Member initialization list<a hidden class=anchor aria-hidden=true href=#-member-initialization-list>#</a></h3><p>Always use the member initialization list to initialize member objects.</p><p>One aspect of C++ that isn&rsquo;t fickle is the order in which an object&rsquo;s data is initialized. This order is always the same: base classes are initialized before derived classes (see also Item 12), and within a class, data members are initialized in the order in which they are declared.</p><h3 id=-initialize-static-objects>üéº Initialize Static Objects<a hidden class=anchor aria-hidden=true href=#-initialize-static-objects>#</a></h3><p>A <strong>static object</strong> is one that exists from the time it&rsquo;s constructed until the end of the program. Stack and heap-based objects are thus excluded.</p><p>Included are:</p><ul><li>global objects</li><li>objects defined at namespace scope</li><li>objects declared static inside classes</li><li>objects declared static inside functions</li><li>objects declared static at file scope</li></ul><p>Static objects inside functions are known as local static objects (because they&rsquo;re local to a function), and the other kinds of static objects are known as non-local static objects.</p><p>Static objects are destroyed when the program exits, i.e., their destructors are called when main finishes executing.</p><p>‚ö† <strong>Warning</strong>: If initialization of a non-local static object in one translation unit uses a non-local static object in a different translation unit, the object it uses could be uninitialized, because <strong>the relative order of initialization of non-local static objects defined in different translation units is undefined</strong>.</p><blockquote><p>üí¨ Multiple translation units and non-local static objects is generated through implicit template instantiations (which may themselves arise via implicit template instantiations). It&rsquo;s not only impossible to determine the right order of initialization, it&rsquo;s typically not even worth looking for special cases where it is possible to determine the right order.</p></blockquote><p>To avoid the problem of undefined initialization order, you can use <strong>a function-local static object</strong> instead of a non-local static object. These functions return references to the objects they contain. (Aficionados of design patterns will recognize this as a common implementation of the <strong>Singleton Pattern</strong>.)</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FileSystem</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>FileSystem</span><span class=o>&amp;</span> <span class=n>tfs</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>FileSystem</span> <span class=n>fs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>fs</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Directory</span> <span class=p>{...};</span>
</span></span><span class=line><span class=cl><span class=n>Directory</span><span class=o>::</span><span class=n>Directory</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>size_t</span> <span class=n>disks</span> <span class=o>=</span> <span class=n>tfs</span><span class=p>().</span><span class=n>numDisks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=n>Directory</span><span class=o>&amp;</span> <span class=n>tempDir</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>Directory</span> <span class=n>td</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>td</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This approach is founded on C++&rsquo;s guarantee that <strong>local static objects are initialized when the object&rsquo;s definition is first encountered during a call to that function</strong>. So if you replace direct accesses to non-local static objects with calls to functions that return references to local static objects, you&rsquo;re guaranteed that the references you get back will refer to initialized objects. As a bonus, if you never call a function emulating a non-local static object, you never incur the cost of constructing and destructing the object, something that can&rsquo;t be said for true non-local static objects.</p><blockquote><p>However, the fact that these functions contain static objects makes them problematic <strong>in multithreaded systems</strong>. Then again, any kind of non-const static object ‚Äî local or non-local ‚Äî is trouble waiting to happen in the presence of multiple threads.</p><p>One way to deal with such trouble is to <strong>manually invoke all the reference-returning functions during the single-threaded startup portion of the program</strong>. This eliminates initialization-related race conditions.</p></blockquote><h3 id=-things-to-remember-1>üéº Things to Remember<a hidden class=anchor aria-hidden=true href=#-things-to-remember-1>#</a></h3><ul><li>Manually initialize objects of built-in type, because C++ only sometimes initializes them itself.</li><li>In a constructor, prefer use of the member initialization list to assignment inside the body of the constructor. List data members in the initialization list in the same order they&rsquo;re declared in the class.</li><li>Avoid initialization order problems across translation units by replacing non-local static objects with local static objects.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jamesnulliu.github.io/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/><span class=title>¬´ Prev</span><br><span>02 | Constructors, Destructorsm and Assignment Operators</span>
</a><a class=next href=https://jamesnulliu.github.io/blogs/build-ffmpeg-against-nvenc/><span class=title>Next ¬ª</span><br><span>Build FFmpeg against NVENC</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=jamesnulliu/jamesnulliu.github.io data-repo-id=R_kgDOMPCQIw data-category=Announcements data-category-id=DIC_kwDOMPCQI84Cgb2t data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>¬© 2024-2025 JamesNULLiu</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>