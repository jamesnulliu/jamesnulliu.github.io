<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>03 | Resource Management | ÁßãÊ∞¥¬∑JamesNULLiu</title><meta name=keywords content="c++"><meta name=description content='My learning notes of "Effective C++" by Scott Meyers.'><meta name=author content="jamesnulliu"><link rel=canonical href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/><link crossorigin=anonymous href=/assets/css/stylesheet.62cb9c488bb33c0e9a9d3c29b7f4259cbb0db25aaa19ba672188203d3d5bcaf9.css integrity="sha256-YsucSIuzPA6anTwpt/QlnLsNslqqGbpnIYggPT1byvk=" rel="preload stylesheet" as=style><link rel=icon href=https://jamesnulliu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jamesnulliu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jamesnulliu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jamesnulliu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jamesnulliu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script><meta property="og:url" content="https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/"><meta property="og:site_name" content="ÁßãÊ∞¥¬∑JamesNULLiu"><meta property="og:title" content="03 | Resource Management"><meta property="og:description" content='My learning notes of "Effective C++" by Scott Meyers.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2024-06-29T00:03:00+08:00"><meta property="article:modified_time" content="2025-09-12T22:14:12+00:00"><meta property="article:tag" content="C++"><meta name=twitter:card content="summary"><meta name=twitter:title content="03 | Resource Management"><meta name=twitter:description content='My learning notes of "Effective C++" by Scott Meyers.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://jamesnulliu.github.io/blogs/"},{"@type":"ListItem","position":2,"name":"üìÅ learning notes: effective c++","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/"},{"@type":"ListItem","position":3,"name":"03 | Resource Management","item":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"03 | Resource Management","name":"03 | Resource Management","description":"My learning notes of \"Effective C++\" by Scott Meyers.","keywords":["c++"],"articleBody":"Term 13: Use objects to manage resources Do not make multiple std::auto_ptrs point to the same object.\nIf one is destroyed, the object would be released automatically.\nSimply put, do not use std::auto_ptr.\nUse RCSP (reference-counting smart pointer) to manage resources:\nstd::shared_ptr\nRemember: both auto_ptr and shared_ptr use delete instead of delete[]. As a result, do not write std::shared_ptr spi(new int[1024]).\nTerm 14: Think carefully about copying behavior in resource-managing classes. Term 13 introduces such concept: Resource Acquisition Is Initialization, RAII. This concept is performed when std::auto_ptr and std::shared_ptr manage heap-based resource.\nNot all resource is heap-based, and it is usual that RCSP is not suitable resource handlers for these resource.\nThat is why sometimes you should write your own resource-managing classes.\nSuppose we use a mutex object with class Mutex, and there are two functions lock() and unlock(). In order not to forget to unlock any locked mutex, it is feasible to write a class Lock to manage the mutex. Example is shown as following:\nclass Lock { public: explicit Lock(Mutex* pm) : mutexPtr(pm) { lock(mutexPtr); } ~Lock() { unlock(mutexPtr); } private: Mutex* mutexPtr; } If we copy a Lock object to another, in most cases you would choose one of the following four options.\nTo Forbid Copying. By following term 6, you can make class Lock inherit from a base class whose copy constructor is declared private. Use Reference-Count for Underlying Resource. Use std::shared_ptr to manage Lock::mutexPtr in stead of Mutex*. However, one question is that what a std::shared_ptr do is when reference-count equals to 0, the underlying pointer is deleted, and that is not what we want. We want to call function unlock. The lucky thing is that std::share_ptr allow users to specify a deleter, so the class Lock can be written as follow: class Lock { public: explicit Lock(Mutex* pm) : mutexPtr(pm, unlock) // Use func {unlock} to sepecify a deleter and initialize a std::shared_ptr { lock(mutexPtr.get()); } // Destructor is omitted because {mutexPtr} would automatically invoke func {unlock}. private: std::shared_ptr\u003cMutex\u003e mutexPtr; } Deep Copying. Transfer Ownership. For example: std::auto_ptr. Term 15: Provide access to raw resources in resource-managing classes std::shared_ptr and std::auto_ptr both provide get() methods to give access to the underlying raw pointers.\nclass Font { public: explicit Font(FontHandle fh) : f(fh) {} ~Font() { releaseFont(f); } FontHandle get() const { return f; } // Explicit conversion operator FontHandle() const { return f; } // Implicit conversion private: FontHandle f; // Raw font resource } Implicit conversion could be dangerous.\nTerm 16: Use the same form in corresponding uses of new and delete. Term 17: Store new objects in smart pointers in standalone statements. Suppose there is a function:\nvoid processWidget(std::shared_ptr\u003cWidget\u003e pw, int priority); Following call of the function is invalid:\nvoid processWidget(new Widget, priority()); The reason is that construction of std::shared_ptr is declared explicitly. If we adjust the statement to:\nvoid processWidget(std::share_ptr\u003cWidget\u003e(new Widget), priority()); This could cause memory leak. The above statement has to do 3 things:\nCall priority() Run new Widget Call constructor of std::shared_ptr In C++, in order to generate more efficient code, the execution sequence could be:\nRun new Widget Call priority() Call constructor of std::share_ptr In this situation, if an exception is thrown when priority() is called, the resource accuired by new Widget would not be free properly. This is memory leak.\nTo avoid this, write as following:\nstd::shared_ptr\u003cWidget\u003e pw(new Widget); processWidget(pw, priority()); ","wordCount":"564","inLanguage":"en","datePublished":"2024-06-29T00:03:00+08:00","dateModified":"2025-09-12T22:14:12Z","author":[{"@type":"Person","name":"jamesnulliu"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/03-resource-management/"},"publisher":{"@type":"Organization","name":"ÁßãÊ∞¥¬∑JamesNULLiu","logo":{"@type":"ImageObject","url":"https://jamesnulliu.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jamesnulliu.github.io/ accesskey=h title="ÁßãÊ∞¥¬∑JamesNULLiu (Alt + H)">ÁßãÊ∞¥¬∑JamesNULLiu</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://jamesnulliu.github.io/zh/ title=ÁÆÄ‰Ωì‰∏≠Êñá aria-label=ÁÆÄ‰Ωì‰∏≠Êñá>ÁÆÄ‰Ωì‰∏≠Êñá</a></li></ul></div></div><ul id=menu><li><a href=https://jamesnulliu.github.io/ title=Home><span>Home</span></a></li><li><a href=https://jamesnulliu.github.io/about_me/ title="About Me"><span>About Me</span></a></li><li><a href=https://jamesnulliu.github.io/blogs/ title=Blogs><span>Blogs</span></a></li><li><a href=https://jamesnulliu.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://jamesnulliu.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jamesnulliu.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://jamesnulliu.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://jamesnulliu.github.io/friends/ title=Friends><span>Friends</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jamesnulliu.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/>Blogs</a>&nbsp;¬ª&nbsp;<a href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/>üìÅ learning notes: effective c++</a></div><h1 class="post-title entry-hint-parent">03 | Resource Management</h1><div class=post-description>My learning notes of "Effective C++" by Scott Meyers.</div><div class=post-meta><span title='2024-06-29 00:03:00 +0800 +0800'>Jun-29-2024</span>&nbsp;¬∑&nbsp;3 min&nbsp;¬∑&nbsp;564 words&nbsp;¬∑&nbsp;jamesnulliu</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#term-13-use-objects-to-manage-resources aria-label="Term 13: Use objects to manage resources">Term 13: Use objects to manage resources</a></li><li><a href=#term-14-think-carefully-about-copying-behavior-in-resource-managing-classes aria-label="Term 14: Think carefully about copying behavior in resource-managing classes.">Term 14: Think carefully about copying behavior in resource-managing classes.</a></li><li><a href=#term-15-provide-access-to-raw-resources-in-resource-managing-classes aria-label="Term 15: Provide access to raw resources in resource-managing classes">Term 15: Provide access to raw resources in resource-managing classes</a></li><li><a href=#term-16-use-the-same-form-in-corresponding-uses-of-new-and-delete aria-label="Term 16: Use the same form in corresponding uses of new and delete.">Term 16: Use the same form in corresponding uses of new and delete.</a></li><li><a href=#term-17-store-new-objects-in-smart-pointers-in-standalone-statements aria-label="Term 17: Store new objects in smart pointers in standalone statements.">Term 17: Store new objects in smart pointers in standalone statements.</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{let e=null;const t=window.innerHeight+window.pageYOffset>=document.body.offsetHeight-100;if(t)e=elements[elements.length-1];else{let t=null,n=1/0;elements.forEach(e=>{const s=getOffsetTop(e)-window.pageYOffset;if(s<=window.innerHeight*.3){const o=Math.abs(s);o<n&&(n=o,t=e)}}),e=t||elements[0]}if(e&&e!==activeElement){if(activeElement){const t=encodeURI(activeElement.getAttribute("id")).toLowerCase(),e=document.querySelector(`.inner ul li a[href="#${t}"]`);e&&e.classList.remove("active")}activeElement=e;const n=encodeURI(activeElement.getAttribute("id")).toLowerCase(),t=document.querySelector(`.inner ul li a[href="#${n}"]`);t&&(t.classList.add("active"),document.getElementById("toc-container").classList.contains("wide")&&scrollTocToActiveItem(t))}},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}function scrollTocToActiveItem(e){const t=document.querySelector(".toc .inner");if(!t||!e)return;const n=t.getBoundingClientRect(),s=e.getBoundingClientRect(),o=n.height/2,i=s.top-n.top+t.scrollTop,a=i-o;t.scrollTo({top:Math.max(0,a),behavior:"smooth"})}</script><div class=post-content><h2 id=term-13-use-objects-to-manage-resources>Term 13: Use objects to manage resources<a hidden class=anchor aria-hidden=true href=#term-13-use-objects-to-manage-resources>#</a></h2><p>Do not make multiple <code>std::auto_ptr</code>s point to the same object.<br>If one is destroyed, the object would be released automatically.</p><p>Simply put, do not use <code>std::auto_ptr</code>.</p><p>Use <strong>RCSP (reference-counting smart pointer)</strong> to manage resources:<br><code>std::shared_ptr</code></p><p>Remember: both <code>auto_ptr</code> and <code>shared_ptr</code> use <code>delete</code> instead of <code>delete[]</code>. As a result, do not write <code>std::shared_ptr&lt;int> spi(new int[1024])</code>.</p><h2 id=term-14-think-carefully-about-copying-behavior-in-resource-managing-classes>Term 14: Think carefully about copying behavior in resource-managing classes.<a hidden class=anchor aria-hidden=true href=#term-14-think-carefully-about-copying-behavior-in-resource-managing-classes>#</a></h2><p>Term 13 introduces such concept: <strong>Resource Acquisition Is Initialization, RAII</strong>. This concept is performed when <code>std::auto_ptr</code> and <code>std::shared_ptr</code> manage heap-based resource.<br>Not all resource is heap-based, and it is usual that RCSP is not suitable resource handlers for these resource.<br>That is why sometimes you should write your own resource-managing classes.</p><p>Suppose we use a mutex object with class <code>Mutex</code>, and there are two functions <code>lock()</code> and <code>unlock()</code>. In order not to forget to unlock any locked mutex, it is feasible to write a class <code>Lock</code> to manage the mutex. Example is shown as following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Lock</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>explicit</span> <span class=n>Lock</span><span class=p>(</span><span class=n>Mutex</span><span class=o>*</span> <span class=n>pm</span><span class=p>)</span> <span class=o>:</span> <span class=n>mutexPtr</span><span class=p>(</span><span class=n>pm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>lock</span><span class=p>(</span><span class=n>mutexPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>unlock</span><span class=p>(</span><span class=n>mutexPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>Mutex</span><span class=o>*</span> <span class=n>mutexPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If we copy a <code>Lock</code> object to another, in most cases you would choose one of the following four options.</p><ul><li><strong>To Forbid Copying</strong>. By following term 6, you can make class <code>Lock</code> inherit from a base class whose copy constructor is declared private.</li><li><strong>Use Reference-Count for Underlying Resource</strong>. Use <code>std::shared_ptr&lt;Mutex></code> to manage <code>Lock::mutexPtr</code> in stead of <code>Mutex*</code>. However, one question is that what a <code>std::shared_ptr</code> do is when reference-count equals to 0, the underlying pointer is deleted, and that is not what we want. We want to call function <code>unlock</code>. The lucky thing is that <code>std::share_ptr</code> allow users to specify a <strong>deleter</strong>, so the class <code>Lock</code> can be written as follow:<div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Lock</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=n>Lock</span><span class=p>(</span><span class=n>Mutex</span><span class=o>*</span> <span class=n>pm</span><span class=p>)</span> <span class=o>:</span> <span class=n>mutexPtr</span><span class=p>(</span><span class=n>pm</span><span class=p>,</span> <span class=n>unlock</span><span class=p>)</span> <span class=c1>// Use func {unlock} to sepecify a deleter and initialize a std::shared_ptr
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>  	  <span class=n>lock</span><span class=p>(</span><span class=n>mutexPtr</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Destructor is omitted because {mutexPtr} would automatically invoke func {unlock}.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Mutex</span><span class=o>&gt;</span> <span class=n>mutexPtr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><strong>Deep Copying</strong>.</li><li><strong>Transfer Ownership</strong>. For example: <code>std::auto_ptr</code>.</li></ul><h2 id=term-15-provide-access-to-raw-resources-in-resource-managing-classes>Term 15: Provide access to raw resources in resource-managing classes<a hidden class=anchor aria-hidden=true href=#term-15-provide-access-to-raw-resources-in-resource-managing-classes>#</a></h2><p><code>std::shared_ptr</code> and <code>std::auto_ptr</code> both provide <code>get()</code> methods to give access to the underlying raw pointers.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Font</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=k>explicit</span> <span class=n>Font</span><span class=p>(</span><span class=n>FontHandle</span> <span class=n>fh</span><span class=p>)</span> <span class=o>:</span> <span class=n>f</span><span class=p>(</span><span class=n>fh</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=o>~</span><span class=n>Font</span><span class=p>()</span> <span class=p>{</span> <span class=n>releaseFont</span><span class=p>(</span><span class=n>f</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>FontHandle</span> <span class=nf>get</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>f</span><span class=p>;</span> <span class=p>}</span>  <span class=c1>// Explicit conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>operator</span> <span class=nf>FontHandle</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>f</span><span class=p>;</span> <span class=p>}</span>  <span class=c1>// Implicit conversion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=n>FontHandle</span> <span class=n>f</span><span class=p>;</span>  <span class=c1>// Raw font resource
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>Implicit conversion could be dangerous.</p><h2 id=term-16-use-the-same-form-in-corresponding-uses-of-new-and-delete>Term 16: Use the same form in corresponding uses of new and delete.<a hidden class=anchor aria-hidden=true href=#term-16-use-the-same-form-in-corresponding-uses-of-new-and-delete>#</a></h2><h2 id=term-17-store-new-objects-in-smart-pointers-in-standalone-statements>Term 17: Store new objects in smart pointers in standalone statements.<a hidden class=anchor aria-hidden=true href=#term-17-store-new-objects-in-smart-pointers-in-standalone-statements>#</a></h2><p>Suppose there is a function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processWidget</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>pw</span><span class=p>,</span> <span class=kt>int</span> <span class=n>priority</span><span class=p>);</span>
</span></span></code></pre></div><p>Following call of the function is invalid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processWidget</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>,</span> <span class=n>priority</span><span class=p>());</span>
</span></span></code></pre></div><p>The reason is that construction of <code>std::shared_ptr</code> is declared explicitly. If we adjust the statement to:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>processWidget</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>share_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>),</span> <span class=n>priority</span><span class=p>());</span>
</span></span></code></pre></div><p>This could cause memory leak. The above statement has to do 3 things:</p><ul><li>Call <code>priority()</code></li><li>Run <code>new Widget</code></li><li>Call constructor of <code>std::shared_ptr</code></li></ul><p>In C++, in order to generate more efficient code, the execution sequence could be:</p><ol><li>Run <code>new Widget</code></li><li>Call <code>priority()</code></li><li>Call constructor of <code>std::share_ptr</code></li></ol><p>In this situation, if an exception is thrown when <code>priority()</code> is called, the resource accuired by <code>new Widget</code> would not be free properly. This is memory leak.</p><p>To avoid this, write as following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>Widget</span><span class=o>&gt;</span> <span class=n>pw</span><span class=p>(</span><span class=k>new</span> <span class=n>Widget</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>processWidget</span><span class=p>(</span><span class=n>pw</span><span class=p>,</span> <span class=n>priority</span><span class=p>());</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jamesnulliu.github.io/tags/c++/>C++</a></li></ul><nav class=paginav><a class=prev href=https://jamesnulliu.github.io/blogs/a-simple-pytorch-trainpipeline/><span class=title>¬´ Prev</span><br><span>A Simple Pytorch Trainpipeline</span>
</a><a class=next href=https://jamesnulliu.github.io/blogs/learning-notes-effective-cxx/02-constructors-destructors-and-assignment-operators/><span class=title>Next ¬ª</span><br><span>02 | Constructors, Destructorsm and Assignment Operators</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=jamesnulliu/jamesnulliu.github.io data-repo-id=R_kgDOMPCQIw data-category=Announcements data-category-id=DIC_kwDOMPCQI84Cgb2t data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en crossorigin=anonymous async></script></article></main><footer class=footer><span>¬© 2024-2025 JamesNULLiu</span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>